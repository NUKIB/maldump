from __future__ import annotations

import json
import logging
from datetime import datetime

from maldump.constants import ThreatMetadata
from maldump.structures import Parser, QuarEntry
from maldump.utils import CustomArc4
from maldump.utils import DatetimeConverter as DTC
from maldump.utils import Logger as log
from maldump.utils import Parser as parse
from maldump.utils import Reader as read

logger = logging.getLogger(__name__)


class MalwarebytesParser(Parser):
    @log.log(lgr=logger)
    def _decrypt(self, plaintext: bytes) -> bytes:
        key = bytes(
            [
                0x03,
                0x7A,
                0x55,
                0xC5,
                0xDF,
                0x39,
                0xD2,
                0x89,
                0x7F,
                0xEF,
                0x88,
                0x3D,
                0xC0,
                0x47,
                0xB3,
                0x17,
            ]
        )
        return CustomArc4(key).decode(plaintext)

    @log.log(lgr=logger)
    def _normalize_time(self, date: str) -> datetime:
        return datetime.strptime(date, "%Y-%m-%dT%H:%M:%SZ")

    def parse_from_log(self, _=None) -> dict[str, QuarEntry]:
        logger.info("Parsing from log in %s", self.name)
        quarfiles = {}

        for idx, metafile in enumerate(self.location.glob("*.data")):
            logger.debug('Parsing entry, idx %s, path "%s"', idx, metafile)
            metadata = read.contents(metafile)
            if metadata is None:
                logger.debug('Skipping entry idx %s, path "%s"', idx, metafile)
                continue

            decrypted = self._decrypt(metadata)
            metadata = json.loads(decrypted)

            # Open corresponding malfile
            uid = metadata["trace"]["objectID"]

            malfile = read.contents(self.location / (uid + ".quar"))
            malfile = b"" if malfile is None else self._decrypt(malfile)

            q = QuarEntry(self)
            q.timestamp = self._normalize_time(metadata["trace"]["cleanTime"])
            q.threat = metadata["threatName"]
            q.path = metadata["trace"]["objectPath"]
            q.md5 = metadata["trace"]["objectMD5"].lower()
            q.malfile = malfile
            quarfiles[uid] = q

        return quarfiles

    def parse_from_fs(
        self, data: dict[str, QuarEntry] | None = None
    ) -> dict[str, QuarEntry]:
        logger.info("Parsing from filesystem in %s", self.name)
        quarfiles = {}

        for idx, entry in enumerate(self.location.glob("*.quar")):
            logger.debug('Parsing entry, idx %s, path "%s"', idx, entry)
            if not entry.is_file():
                logger.debug("Entry (idx %s) is not a file, skipping", idx)
                continue

            uid = entry.name.rstrip(".quar")
            if uid in data:
                logger.debug("Entry (idx %s) already found, skipping", idx)
                continue

            entry_stat = parse(self).entry_stat(entry)
            if entry_stat is None:
                logger.debug('Skipping entry idx %s, path "%s"', idx, entry)
                continue
            timestamp = DTC.get_dt_from_stat(entry_stat)
            size = entry_stat.st_size

            malfile = read.contents(entry)
            malfile = b"" if malfile is None else self._decrypt(malfile)

            q = QuarEntry(self)
            q.path = str(entry)
            q.timestamp = timestamp
            q.size = size
            q.threat = ThreatMetadata.UNKNOWN_THREAT
            q.malfile = malfile
            quarfiles[uid] = q

        return quarfiles
