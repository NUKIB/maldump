from __future__ import annotations

import json
import logging
from datetime import datetime

from maldump.constants import ThreatMetadata
from maldump.structures import Parser, QuarEntry
from maldump.utils import CustomArc4
from maldump.utils import DatetimeConverter as DTC
from maldump.utils import Parser as parse
from maldump.utils import Reader as read


def log_fn(func):
    def wrapper(*args, **kwargs):
        logging.debug(
            "Calling function: %s, arguments: %s, keyword arguments: %s",
            func.__name__,
            tuple(
                (
                    arg
                    if type(arg) not in {bytes, MalwarebytesParser}
                    else "<" + type(arg).__name__ + ">"
                )
                for arg in args
            ),
            kwargs,
        )
        return func(*args, **kwargs)

    return wrapper


class MalwarebytesParser(Parser):
    @log_fn
    def _decrypt(self, plaintext: bytes) -> bytes:
        key = bytes(
            [
                0x03,
                0x7A,
                0x55,
                0xC5,
                0xDF,
                0x39,
                0xD2,
                0x89,
                0x7F,
                0xEF,
                0x88,
                0x3D,
                0xC0,
                0x47,
                0xB3,
                0x17,
            ]
        )
        return CustomArc4(key).decode(plaintext)

    @log_fn
    def _normalize_time(self, date: str) -> datetime:
        return datetime.strptime(date, "%Y-%m-%dT%H:%M:%SZ")

    def parse_from_log(self, _=None) -> dict[str, QuarEntry]:
        logging.info("Parsing from log in %s", self.name)
        quarfiles = {}

        for idx, metafile in enumerate(self.location.glob("*.data")):
            logging.debug('Parsing entry, idx %s, path "%s"', idx, metafile)
            metadata = read.contents(metafile)
            if metadata is None:
                logging.debug('Skipping entry idx %s, path "%s"', idx, metafile)
                continue

            decrypted = self._decrypt(metadata)
            metadata = json.loads(decrypted)

            # Open corresponding malfile
            uid = metadata["trace"]["objectID"]

            malfile = read.contents(self.location / (uid + ".quar"))
            if malfile is None:
                malfile = b""
            else:
                malfile = self._decrypt(malfile)

            q = QuarEntry()
            q.timestamp = self._normalize_time(metadata["trace"]["cleanTime"])
            q.threat = metadata["threatName"]
            q.path = metadata["trace"]["objectPath"]
            q.md5 = metadata["trace"]["objectMD5"].lower()
            q.malfile = malfile
            quarfiles[uid] = q

        return quarfiles

    def parse_from_fs(
        self, data: dict[str, QuarEntry] | None = None
    ) -> dict[str, QuarEntry]:
        logging.info("Parsing from filesystem in %s", self.name)
        quarfiles = {}

        for idx, entry in enumerate(self.location.glob("*.quar")):
            logging.debug('Parsing entry, idx %s, path "%s"', idx, entry)
            if not entry.is_file():
                logging.debug("Entry (idx %s) is not a file, skipping", idx)
                continue

            uid = entry.name.rstrip(".quar")
            if uid in data:
                logging.debug("Entry (idx %s) already found, skipping", idx)
                continue

            entry_stat = parse(self).entry_stat(entry)
            if entry_stat is None:
                logging.debug('Skipping entry idx %s, path "%s"', idx, entry)
                continue
            timestamp = DTC.get_dt_from_stat(entry_stat)
            size = entry_stat.st_size

            malfile = read.contents(entry)
            if malfile is None:
                malfile = b""
            else:
                malfile = self._decrypt(malfile)

            q = QuarEntry()
            q.path = str(entry)
            q.timestamp = timestamp
            q.size = size
            q.threat = ThreatMetadata.UNKNOWN_THREAT
            q.malfile = malfile
            quarfiles[uid] = q

        return quarfiles
